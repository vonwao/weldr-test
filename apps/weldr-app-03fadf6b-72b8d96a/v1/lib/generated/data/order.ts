'use client';

// @generated by Weldr.dev â€” data hooks managed. Wire real data sources inside @custom regions or dedicated adapters.

import { useCallback, useEffect, useState } from 'react';
import type { Order, OrderInput, OrderUpdate } from '@/lib/types';

type OrderUpdateInput = OrderUpdate & { id: string };

// Generated data hooks for Order
// NOTE: Replace fetch implementations with real data sources as needed.

type OrderActionResult<TData = Order> =
  | { ok: true; data: TData; message?: string }
  | { ok: false; error: Error; message?: string };

export function useOrderList() {
  const [data, setData] = useState<Order[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);

  const fetchData = useCallback(async () => {
    setIsLoading(true);
    setError(null);

    try {
      const response = await fetch('/api/order');
      if (!response.ok) {
        throw new Error('Failed to load Order list.');
      }
      const payload: Order[] = await response.json();
      setData(payload);
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Failed to load Order list.';
      setError(new Error(message));
    } finally {
      setIsLoading(false);
    }
  }, []);

  useEffect(() => {
    void fetchData();
  }, [fetchData]);

  return { data, isLoading, error, refresh: fetchData };
}

export function useOrderDetail(id: string | null) {
  const [data, setData] = useState<Order | null>(null);
  const [isLoading, setIsLoading] = useState(Boolean(id));
  const [error, setError] = useState<Error | null>(null);

  const fetchData = useCallback(async () => {
    if (!id) {
      setData(null);
      setIsLoading(false);
      return;
    }

    setIsLoading(true);
    setError(null);

    try {
      const response = await fetch(`/api/order/${id}`);
      if (!response.ok) {
        throw new Error('Failed to load Order detail.');
      }
      const payload: Order = await response.json();
      setData(payload);
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Failed to load Order detail.';
      setError(new Error(message));
    } finally {
      setIsLoading(false);
    }
  }, [id]);

  useEffect(() => {
    void fetchData();
  }, [fetchData]);

  return { data, isLoading, error, refresh: fetchData };
}

export interface useCreateOrderOptions {
  onSuccess?: (payload: Order) => void;
  onError?: (error: Error) => void;
  defaultSuccessMessage?: string;
  defaultErrorMessage?: string;
}

export function useCreateOrder(options: useCreateOrderOptions = {}) {
  const { onSuccess, onError, defaultSuccessMessage, defaultErrorMessage } = options;
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);
  const [lastResult, setLastResult] = useState<OrderActionResult<Order> | null>(null);

  const execute = useCallback(async (input: OrderInput) => {
    setIsLoading(true);
    setError(null);

    try {
      const response = await fetch('/api/order', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(input),
      });
      const payload = await response.json().catch(() => ({}));
      if (!response.ok) {
        const message =
          typeof payload?.error === 'string' ? payload.error : (defaultErrorMessage ?? 'Failed to create Order.');
        const err = new Error(message);
        setError(err);
        setLastResult({ ok: false, error: err, message });
        onError?.(err);
        return { ok: false as const, error: err, message };
      }

      const message =
        typeof payload?.message === 'string' ? payload.message : (defaultSuccessMessage ?? 'Order created successfully.');
      setLastResult({ ok: true, data: payload as Order, message });
      onSuccess?.(payload as Order);
      return { ok: true as const, data: payload as Order, message } satisfies OrderActionResult<Order>;
    } catch (err) {
      const error = err instanceof Error ? err : new Error(defaultErrorMessage ?? 'Failed to create Order.');
      setError(error);
      setLastResult({ ok: false, error, message: error.message });
      onError?.(error);
      return { ok: false as const, error, message: error.message } satisfies OrderActionResult<Order>;
    } finally {
      setIsLoading(false);
    }
  }, [defaultErrorMessage, defaultSuccessMessage, onError, onSuccess]);

  const reset = useCallback(() => {
    setError(null);
    setLastResult(null);
  }, []);

  return { execute, isLoading, error, lastResult, reset };
}

export interface useUpdateOrderOptions {
  onSuccess?: (payload: Order) => void;
  onError?: (error: Error) => void;
  defaultSuccessMessage?: string;
  defaultErrorMessage?: string;
}

export function useUpdateOrder(options: useUpdateOrderOptions = {}) {
  const { onSuccess, onError, defaultSuccessMessage, defaultErrorMessage } = options;
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);
  const [lastResult, setLastResult] = useState<OrderActionResult<Order> | null>(null);

  const execute = useCallback(async (input: OrderUpdateInput) => {
    setIsLoading(true);
    setError(null);

    try {
      const response = await fetch(`/api/order/${input.id}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(input),
      });
      const payload = await response.json().catch(() => ({}));
      if (!response.ok) {
        const message =
          typeof payload?.error === 'string' ? payload.error : (defaultErrorMessage ?? 'Failed to update Order.');
        const err = new Error(message);
        setError(err);
        setLastResult({ ok: false, error: err, message });
        onError?.(err);
        return { ok: false as const, error: err, message };
      }

      const message =
        typeof payload?.message === 'string' ? payload.message : (defaultSuccessMessage ?? 'Order updated successfully.');
      setLastResult({ ok: true, data: payload as Order, message });
      onSuccess?.(payload as Order);
      return { ok: true as const, data: payload as Order, message } satisfies OrderActionResult<Order>;
    } catch (err) {
      const error = err instanceof Error ? err : new Error(defaultErrorMessage ?? 'Failed to update Order.');
      setError(error);
      setLastResult({ ok: false, error, message: error.message });
      onError?.(error);
      return { ok: false as const, error, message: error.message } satisfies OrderActionResult<Order>;
    } finally {
      setIsLoading(false);
    }
  }, [defaultErrorMessage, defaultSuccessMessage, onError, onSuccess]);

  const reset = useCallback(() => {
    setError(null);
    setLastResult(null);
  }, []);

  return { execute, isLoading, error, lastResult, reset };
}

export interface useDeleteOrderOptions {
  onSuccess?: (id: string) => void;
  onError?: (error: Error) => void;
  defaultSuccessMessage?: string;
  defaultErrorMessage?: string;
}

export function useDeleteOrder(options: useDeleteOrderOptions = {}) {
  const { onSuccess, onError, defaultSuccessMessage, defaultErrorMessage } = options;
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);
  const [lastResult, setLastResult] = useState<OrderActionResult<string> | null>(null);

  const execute = useCallback(async (input: { id: string } | string) => {
    const identifier = typeof input === 'string' ? input : input.id;
    setIsLoading(true);
    setError(null);

    try {
      const response = await fetch(`/api/order/${identifier}`, {
        method: 'DELETE',
      });
      const payload = await response.json().catch(() => ({}));
      if (!response.ok) {
        const message =
          typeof payload?.error === 'string' ? payload.error : (defaultErrorMessage ?? 'Failed to delete Order.');
        const err = new Error(message);
        setError(err);
        setLastResult({ ok: false, error: err, message });
        onError?.(err);
        return { ok: false as const, error: err, message };
      }

      const message =
        typeof payload?.message === 'string' ? payload.message : (defaultSuccessMessage ?? 'Order deleted successfully.');
      setLastResult({ ok: true, data: identifier, message });
      onSuccess?.(identifier);
      return { ok: true as const, data: identifier, message } satisfies OrderActionResult<string>;
    } catch (err) {
      const error = err instanceof Error ? err : new Error(defaultErrorMessage ?? 'Failed to delete Order.');
      setError(error);
      setLastResult({ ok: false, error, message: error.message });
      onError?.(error);
      return { ok: false as const, error, message: error.message } satisfies OrderActionResult<string>;
    } finally {
      setIsLoading(false);
    }
  }, [defaultErrorMessage, defaultSuccessMessage, onError, onSuccess]);

  const reset = useCallback(() => {
    setError(null);
    setLastResult(null);
  }, []);

  return { execute, isLoading, error, lastResult, reset };
}
