'use client';

// @generated by Weldr.dev â€” data hooks managed. Wire real data sources inside @custom regions or dedicated adapters.

import { useCallback, useEffect, useState } from 'react';
import type { Product, ProductInput, ProductUpdate } from '@/lib/types';

type ProductUpdateInput = ProductUpdate & { id: string };

// Generated data hooks for Product
// NOTE: Replace fetch implementations with real data sources as needed.

type ProductActionResult<TData = Product> =
  | { ok: true; data: TData; message?: string }
  | { ok: false; error: Error; message?: string };

export function useProductList() {
  const [data, setData] = useState<Product[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);

  const fetchData = useCallback(async () => {
    setIsLoading(true);
    setError(null);

    try {
      const response = await fetch('/api/product');
      if (!response.ok) {
        throw new Error('Failed to load Product list.');
      }
      const payload: Product[] = await response.json();
      setData(payload);
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Failed to load Product list.';
      setError(new Error(message));
    } finally {
      setIsLoading(false);
    }
  }, []);

  useEffect(() => {
    void fetchData();
  }, [fetchData]);

  return { data, isLoading, error, refresh: fetchData };
}

export function useProductDetail(id: string | null) {
  const [data, setData] = useState<Product | null>(null);
  const [isLoading, setIsLoading] = useState(Boolean(id));
  const [error, setError] = useState<Error | null>(null);

  const fetchData = useCallback(async () => {
    if (!id) {
      setData(null);
      setIsLoading(false);
      return;
    }

    setIsLoading(true);
    setError(null);

    try {
      const response = await fetch(`/api/product/${id}`);
      if (!response.ok) {
        throw new Error('Failed to load Product detail.');
      }
      const payload: Product = await response.json();
      setData(payload);
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Failed to load Product detail.';
      setError(new Error(message));
    } finally {
      setIsLoading(false);
    }
  }, [id]);

  useEffect(() => {
    void fetchData();
  }, [fetchData]);

  return { data, isLoading, error, refresh: fetchData };
}

export interface useCreateProductOptions {
  onSuccess?: (payload: Product) => void;
  onError?: (error: Error) => void;
  defaultSuccessMessage?: string;
  defaultErrorMessage?: string;
}

export function useCreateProduct(options: useCreateProductOptions = {}) {
  const { onSuccess, onError, defaultSuccessMessage, defaultErrorMessage } = options;
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);
  const [lastResult, setLastResult] = useState<ProductActionResult<Product> | null>(null);

  const execute = useCallback(async (input: ProductInput) => {
    setIsLoading(true);
    setError(null);

    try {
      const response = await fetch('/api/product', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(input),
      });
      const payload = await response.json().catch(() => ({}));
      if (!response.ok) {
        const message =
          typeof payload?.error === 'string' ? payload.error : (defaultErrorMessage ?? 'Failed to create Product.');
        const err = new Error(message);
        setError(err);
        setLastResult({ ok: false, error: err, message });
        onError?.(err);
        return { ok: false as const, error: err, message };
      }

      const message =
        typeof payload?.message === 'string' ? payload.message : (defaultSuccessMessage ?? 'Product created successfully.');
      setLastResult({ ok: true, data: payload as Product, message });
      onSuccess?.(payload as Product);
      return { ok: true as const, data: payload as Product, message } satisfies ProductActionResult<Product>;
    } catch (err) {
      const error = err instanceof Error ? err : new Error(defaultErrorMessage ?? 'Failed to create Product.');
      setError(error);
      setLastResult({ ok: false, error, message: error.message });
      onError?.(error);
      return { ok: false as const, error, message: error.message } satisfies ProductActionResult<Product>;
    } finally {
      setIsLoading(false);
    }
  }, [defaultErrorMessage, defaultSuccessMessage, onError, onSuccess]);

  const reset = useCallback(() => {
    setError(null);
    setLastResult(null);
  }, []);

  return { execute, isLoading, error, lastResult, reset };
}

export interface useUpdateProductOptions {
  onSuccess?: (payload: Product) => void;
  onError?: (error: Error) => void;
  defaultSuccessMessage?: string;
  defaultErrorMessage?: string;
}

export function useUpdateProduct(options: useUpdateProductOptions = {}) {
  const { onSuccess, onError, defaultSuccessMessage, defaultErrorMessage } = options;
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);
  const [lastResult, setLastResult] = useState<ProductActionResult<Product> | null>(null);

  const execute = useCallback(async (input: ProductUpdateInput) => {
    setIsLoading(true);
    setError(null);

    try {
      const response = await fetch(`/api/product/${input.id}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(input),
      });
      const payload = await response.json().catch(() => ({}));
      if (!response.ok) {
        const message =
          typeof payload?.error === 'string' ? payload.error : (defaultErrorMessage ?? 'Failed to update Product.');
        const err = new Error(message);
        setError(err);
        setLastResult({ ok: false, error: err, message });
        onError?.(err);
        return { ok: false as const, error: err, message };
      }

      const message =
        typeof payload?.message === 'string' ? payload.message : (defaultSuccessMessage ?? 'Product updated successfully.');
      setLastResult({ ok: true, data: payload as Product, message });
      onSuccess?.(payload as Product);
      return { ok: true as const, data: payload as Product, message } satisfies ProductActionResult<Product>;
    } catch (err) {
      const error = err instanceof Error ? err : new Error(defaultErrorMessage ?? 'Failed to update Product.');
      setError(error);
      setLastResult({ ok: false, error, message: error.message });
      onError?.(error);
      return { ok: false as const, error, message: error.message } satisfies ProductActionResult<Product>;
    } finally {
      setIsLoading(false);
    }
  }, [defaultErrorMessage, defaultSuccessMessage, onError, onSuccess]);

  const reset = useCallback(() => {
    setError(null);
    setLastResult(null);
  }, []);

  return { execute, isLoading, error, lastResult, reset };
}

export interface useDeleteProductOptions {
  onSuccess?: (id: string) => void;
  onError?: (error: Error) => void;
  defaultSuccessMessage?: string;
  defaultErrorMessage?: string;
}

export function useDeleteProduct(options: useDeleteProductOptions = {}) {
  const { onSuccess, onError, defaultSuccessMessage, defaultErrorMessage } = options;
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);
  const [lastResult, setLastResult] = useState<ProductActionResult<string> | null>(null);

  const execute = useCallback(async (input: { id: string } | string) => {
    const identifier = typeof input === 'string' ? input : input.id;
    setIsLoading(true);
    setError(null);

    try {
      const response = await fetch(`/api/product/${identifier}`, {
        method: 'DELETE',
      });
      const payload = await response.json().catch(() => ({}));
      if (!response.ok) {
        const message =
          typeof payload?.error === 'string' ? payload.error : (defaultErrorMessage ?? 'Failed to delete Product.');
        const err = new Error(message);
        setError(err);
        setLastResult({ ok: false, error: err, message });
        onError?.(err);
        return { ok: false as const, error: err, message };
      }

      const message =
        typeof payload?.message === 'string' ? payload.message : (defaultSuccessMessage ?? 'Product deleted successfully.');
      setLastResult({ ok: true, data: identifier, message });
      onSuccess?.(identifier);
      return { ok: true as const, data: identifier, message } satisfies ProductActionResult<string>;
    } catch (err) {
      const error = err instanceof Error ? err : new Error(defaultErrorMessage ?? 'Failed to delete Product.');
      setError(error);
      setLastResult({ ok: false, error, message: error.message });
      onError?.(error);
      return { ok: false as const, error, message: error.message } satisfies ProductActionResult<string>;
    } finally {
      setIsLoading(false);
    }
  }, [defaultErrorMessage, defaultSuccessMessage, onError, onSuccess]);

  const reset = useCallback(() => {
    setError(null);
    setLastResult(null);
  }, []);

  return { execute, isLoading, error, lastResult, reset };
}
